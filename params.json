{"name":"Niuben.GitHub.io","tagline":"博客","body":"# Webpack CommonChunkPlugin详解\r\n\r\n## webpack介绍\r\n### Webpack最近比较流行前端构建工具.它通过分析代码中require调用方式，将代码进行模块化打包，相关多个JS文件会打包成一个文件。同时Webpack还具有MD5版本、内置开发调试服务器等功能；相比Grunt和Gulp等任务流构建工具，Webpack具有模块化打包能力。\r\n### CommonChunkPlugin插件是Webpack官方插件，用于公共文件提取打包；将多个模块都调用到文件，打包到一个公共Chunk中；避免多个模块重复打包相同文件，大大降低整体文件大小；\r\n\r\n##CommonChunkPlugin参数列表\r\n\r\n* name: 公共包名称叫什么。如果存在包名和name相同的话，这个包会变成公共包；如果name是数组会调用数组中每个名字；每个名字都可能是公共文件；如果这个参数没有赋值，所有包都会被选中；\r\n* filename: 公共包文件格式；\r\n* minChunks: 一个包放入公共包需要的最小次数；\r\n* chunks: 那些包会被选中，如果这个值忽略，所有entry包都会被选中；\r\n* children: 如果为true，公共包子元素都会被选中；\r\n* async: 如果为true，会创建一个async公共包，会和其他包共同加载；\r\n* minsize: 可以打包的最小质量；比如100KB；\r\n\r\n\r\n## CommonChunkPlugin实现原理\r\n### 调试Webpack\r\n前端需要使用工具来调试，方便知道程序中变量的值和逻辑运行情况；node-inspector是专门调试node程序；使用之前需要将node版本升级，如果版本过低，有些功能无法使用；按照使用如下：\r\n* npm install node-inspector -g  \r\n* npm-inspector\r\n* 进入项目文件夹，找到webpack.config.js文件；\r\n* node --debug-brk node_modules/webpack/bin/webpack.js(webpack所在文件夹）\r\n* 打开chrome浏览器，输入http://127.0.0.1:8080/?ws=127.0.0.1:8080&port=5858；\r\n\r\n### 公共文件数据结构\r\n有三个数据类型需要理解：block、module、chunk；\r\n* block：\r\n* module：一个commonJS或者AMD文件；\r\n* chunk：多个module打包生成的；\r\n\r\n### 实现原理\r\n<pre>if(!chunkNames && (selectedChunks === false || async)) {\r\n   commonChunks = chunks;\r\n}else if(Array.isArray(chunkNames)) {\r\n    commonChunks = chunkNames.map(function(chunkName) {\r\n    return chunks.filter(function(chunk) {\r\n        return chunk.name === chunkName;\r\n    })[0];\r\n });\r\n } else {\r\n    commonChunks = chunks.filter(function(chunk) {\r\n        return chunk.name === chunkNames;\r\n    });\r\n}</pre>\r\n### 通过配置中name属性，将commonChunks进行赋值；\r\n\r\n<pre>\r\nif(Array.isArray(selectedChunks)) {\r\n    usedChunks = chunks.filter(function(chunk) {\r\n        if(chunk === commonChunk) return false;\r\n        return selectedChunks.indexOf(chunk.name) >= 0;\r\n    });\r\n} else if(selectedChunks === false || async) {\r\n    usedChunks = (commonChunk.chunks || []).filter(function(chunk) {\r\n           // we can only move modules from this chunk if the \"commonChunk\" is the only parent\r\n\t   return async || chunk.parents.length === 1;\r\n     });\r\n} else {\r\n   if(!commonChunk.entry) {\r\n         compilation.errors.push(new Error(\"CommonsChunkPlugin: While running in normal mode it's not allowed to use a non-entry chunk (\" + commonChunk.name + \")\"));\r\n\t\t\t\t\t\treturn;\r\n   }\r\n   usedChunks = chunks.filter(function(chunk) {\r\n      var found = commonChunks.indexOf(chunk);\r\n      if(found >= idx) return false;\r\n      return chunk.entry;\r\n   });\r\n}</pre>\r\n### 获得被使用的包；\r\n\r\n<pre>usedChunks.forEach(function(chunk) {\r\n    chunk.modules.forEach(function(module) {\r\n       var idx = commonModules.indexOf(module);\r\n       if(idx < 0) {\r\n\t   commonModules.push(module);\r\n\t   commonModulesCount.push(1);\r\n       } else {\r\n\t   commonModulesCount[idx]++;\r\n       }\r\n    });\r\n});</pre>\r\n\r\n### 使用包中每个模块被调用的个数；\r\n\r\n<pre>commonModulesCount.forEach(function(count, idx) {\r\n     var module = commonModules[idx];\r\n     if(typeof minChunks === \"function\") {\r\n          if(!minChunks(module, count))\r\n\t\t return;\r\n     } else if(count < (minChunks || Math.max(2, usedChunks.length))) {\r\n\t return;\r\n     }\r\n     reallyUsedModules.push(module);\r\n});</pre>\r\n### 将大于minChunks的module存入到reallyUsedModules中；\r\n\r\n<pre>reallyUsedModules.forEach(function(module) {\r\n     usedChunks.forEach(function(chunk) {\r\n          if(module.removeChunk(chunk)) {\r\n\t\t  if(reallyUsedChunks.indexOf(chunk) < 0)\r\n\t\t       reallyUsedChunks.push(chunk);\r\n\t\t   }\r\n\t  });\r\n\t  commonChunk.addModule(module);\r\n\t  module.addChunk(commonChunk);\r\n });</pre>\r\n\r\n### 将多次调佣module存入CommonChunk中；\r\n\r\n<pre>reallyUsedChunks.forEach(function(chunk) {\r\n     if(chunk.initial || chunk.entry)\r\n\t  return;\r\n     chunk.blocks.forEach(function(block) {\r\n        block.chunks.unshift(commonChunk);\r\n        commonChunk.addBlock(block);\r\n     });\r\n});\r\nasyncChunk.origins = reallyUsedChunks.map(function(chunk) {\r\n   return chunk.origins.map(function(origin) {\r\n      var newOrigin = Object.create(origin);\r\n      newOrigin.reasons = (origin.reasons || []).slice();\r\n      newOrigin.reasons.push(\"async commons\");\r\n      return newOrigin;\r\n   });\r\n}).reduce(function(arr, a) {\r\n    arr.push.apply(arr, a);\r\n   return arr;\r\n}, []);</pre>\r\n### 公共包增加Block","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}